# 实现阻塞读且并发安全的map

GO里面MAP如何实现key不存在 get操作等待 直到key存在或者超时，保证并发安全，且需要实现以下接口：

```go
type sp interface {
    Out(key string, val interface{})  //存入key /val，如果该key读取的goroutine挂起，则唤醒。此方法不会阻塞，时刻都可以立即执行并返回
    Rd(key string, timeout time.Duration) interface{}  //读取一个key，如果key不存在阻塞，等待key存在或者超时
}
```

**解析：**

看到阻塞协程第一个想到的就是`channel`，题目中要求并发安全，那么必须用锁，还要实现多个`goroutine`读的时候如果值不存在则阻塞，直到写入值，那么每个键值需要有一个阻塞`goroutine` 的 `channel`。

[实现如下：](../src/q010.go) 

```go
type Map struct {
	c   map[string]*entry
	rmx *sync.RWMutex
}
type entry struct {
	ch      chan struct{}
	value   interface{}
	isExist bool
}

func (m *Map) Out(key string, val interface{}) {
	m.rmx.Lock()
	defer m.rmx.Unlock()
	item, ok := m.c[key]
	if !ok {
		m.c[key] = &entry{
			value: val,
			isExist: true,
		}
		return
	}
	item.value = val
	if !item.isExist {
		if item.ch != nil {
			close(item.ch)
			item.ch = nil
		}
	}
	return
}
```
* 自己实现了一个版本
```package main

import (
	"fmt"
	"sync"
	"time"
)

type sp interface {
	Out(key string, val interface{})                  //存入key /val，如果该key读取的goroutine挂起，则唤醒。此方法不会阻塞，时刻都可以立即执行并返回
	Rd(key string, timeout time.Duration) interface{} //读取一个key，如果key不存在阻塞，等待key存在或者超时
}

type SyncMap struct {
	entry  map[string]chan bool
	entryV map[string]interface{}
	sync.RWMutex
}

func (sm *SyncMap) Out(key string, val interface{}) {

		sm.Lock()
		defer sm.Unlock()
		fmt.Printf("set value :%v\n",val.(string))
		sm.entryV[key] = val
		vchan := make(chan bool)
		sm.entry[key]=vchan
		//chan 里面有数据了
		go func() {
			vchan <-true
		}()
		fmt.Println("done!")

}
func (sm *SyncMap) Rd(key string, timeout time.Duration) interface{} {
	sm.Lock()
	defer sm.Unlock()
	//先判断存在不，不存在直接等待
	if v, ok := sm.entryV[key]; ok {
		return v
	} else {
		for {
			  if sm.entry[key] == nil{
			  	continue
			  }
			select {

			case _, ok := <-sm.entry[key]:
				//如果ok说明有chan,如果有chan那一定有值
				if ok {
					return sm.entryV[key]
				}else {//chan 关闭的情况直接跳出去，让他for 循环去
					break
				}
			case <-time.After(timeout):
				return nil
			}
		}
	}
}

func main() {
	syncmap := &SyncMap{
		entry:  make(map[string]chan bool),
		entryV: make(map[string]interface{}),
	}
	var s interface{} = "22"
	syncmap.Out("haha", s)
	syncmap.Out("haha", "33")
	syncmap.Out("haha", "44")

	println(syncmap.Rd("haha", 4*time.Second).(string))
	go func() {print(syncmap.Rd("zz", 3*time.Second).(string))}()
		syncmap.Out("zz", "66")
}
```
